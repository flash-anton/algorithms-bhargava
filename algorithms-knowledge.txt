---- Общее -------------------------------------------------------------------------------------------------------------
! В книге допущено много опечаток на картинках (код, таблицы, структуры).

Скорости алгоритмов в порядке возрастания:
O(logN) - бинарный поиск.
O(N) - простой поиск.
O(N*logN) - быстрая сортировка со средним/случайным опорным элементом.
O(N*logN) - сортировка слиянием.
O(N^2) - сортировка выбором.
O(N!) - задача о коммивояжере.

Скорость операций со структурами данных:
        Массив Список ХэшМапа ХэшМапа
                      (средн) (худш)
Чтение   O(1)   O(N)   O(1)    O(N)
Вставка  O(N)   O(1)   O(1)    O(N)
Удаление O(N)   O(1)   O(1)    O(N)

Если O-скорости алгоритмов равны, то нужно сравнивать константы, затем остальные "незначительные" слагаемые.

Упоминаются структуры данных:
- массив
- список
- очередь
- стек
- хеш-таблица
- граф
- дерево (подвид графа)

Если ребра графа имеют вес, то он называется взвешенным(A-4-B), иначе - невзвешенным (A--B).
Если ребра графа имеют направление, то он называется направленным (A-->B), иначе - ненаправленным (A--B).
Если граф ненаправленный (A--B) или имеет двунаправленное ребро (A<-->B), то он называется циклическим, иначе - ациклическим.
Направленный ациклический граф (DAG, Directed Acyclic Graph)

---- 1. Бинарный поиск O(logN) -----------------------------------------------------------------------------------------
Берется отсортированный массив.
Результат - индекс искомого элемента в массиве, либо null.
Берем массив - если искомый элемент равен центральному, то индекс найден, либо
  берем соответствующую половину массива - индекс найден, либо
    берем четвертину ... пока не найдется, либо не останется один элемент неравный искомому.
Худший случай - количество делений массива пополам, пока не останется 1 элемент - log от N по основанию 2.
Скорость алгоритма = O(logN).

---- 2. Сортировка выбором O(N^2) --------------------------------------------------------------------------------------
Делается N итераций: N сравнений + (N-1) сравнений + (N-2) + ... + 1.
Это равнозначно N/2 итерациям по (N+1) сравнений: ((N) + (1)) + ((N-1) + (2)) + ...
Скорость алгоритма = O(N/2 * (N+1)) = O(1/2N^2 + 1/2N) = O(N^2 + N) = O(N^2)

---- 3. Рекурсия -------------------------------------------------------------------------------------------------------
Рекурсия - вызов себя, если не выполнено условие.
Хвостовая рекурсия - читать отдельно.
Упомянут стек.

---- 4. Быстрая сортировка O(N*logN) -----------------------------------------------------------------------------------
Упомянута стратегия "Разделяй и властвуй" - рекурсивный метод.
Быстрая сортировка использует стратегию "Разделяй и властвуй".
Берем массив
  - выбираем случайный опорный элемент
  - слева формируем массив из меньших элементов, справа - остальные
  - берем каждый из массивов по отдельности
    - выбираем опорный элемент
    - ...
      ...  пока массивы не станут размером 0, 1 или 2 (простые случаи)
  - конкатенируем левый массив, опорный элемент, правый массив.
O(N*logN) - средний и случайный случай, когда в качестве опорного берется случайный (не крайний) элемент.
O(N^2)    - худший случай, когда в качестве опорного берется крайний (минимальный/максимальный).

---- 5. Хэш-таблицы ----------------------------------------------------------------------------------------------------
Массив, в каждой ячейке которого список.
Ключ -> хэш-функция -> индекс ячейки массива (основа хэш-таблицы).
Если несколько ключей хэшируются одинаково, то все они добавляются в список одной ячейки.
Увеличивать размер массива рекомендуется, когда коэффициент заполнения превышает 70%.

---- 6. Поиск в ширину (BFS, breadth first search) O(V+E) --------------------------------------------------------------
Поиск в ширину позволяет найти кратчайший по количеству вершин путь.
Алгоритм отвечает на 2 вопроса:
- существует ли путь от узла А до узла Б?
- как выглядит кратчайший путь от узла А до узла Б?
Скорость алгоритма - O(V+E), где V - кол-во вершин, E - кол-во ребер.
Направление стрелок: (родитель)<-(ребенок), (сначала)<-(потом).
Топологическая сортировка - упорядоченный действительный список на основе графа.

---- 7. Алгоритм Дейкстры (Dijkstra) O(V^2) ----------------------------------------------------------------------------
Алгоритм Дейкстры позволяет найти кратчайший по весу путь.
Алгоритм работает только со взвешенным направленным ациклическим графом без отрицательных весов.
Если есть ребро с отрицательным весом, то нужно использовать алгоритм Беллмана-Форда.
Этапы:
1. Среди еще нерассмотренных найти узел с кратчайшим путем от начального.
2. Изменить путь соседа, если путь до него от начального через рассматриваемый станет короче.
3. Повторить для каждого узла.
4. Вычислить итоговый путь.
